#!/bin/perl

# 11.	Фильмы: ID, название, описание, жанр (категория), длительность, популярность (рейтинг), показывается ли сейчас (сегодня), в каких кинотеатрах показывается, цены на билеты (средние).

use Data::Dumper qw(Dumper);

# в этих переменных будут хранится ссылки на эти данные
# Здесь будет первая строка с названиями столбцов - массив строк
my $headings = ();
# здесь будет все данные
# данные будут такие:  [ ['строка1', 'строка2', 'строка3'],  ['строка1', 'строка2', 'строка3'], ['строка1', 'строка2', 'строка3']] - двумерный массив
my $records = ();

my $fh;
my $fileName = "movies.txt";

# загружает данные из файла в переменные нашей проги
sub LoadDataFromFile {
    local $inText = "";
    # индекс, чтоб выбрать 1 строку из данных файла (заголовки) и вынести её отдельно
    # потом индекс будет 0,1,2,... заполнять массив с данными
    local $index = -1;
    # сначала запишу данные сюда, структура такая же как и у $headings и у $records
    local @arrHeadings = ();
    local @arrData = ();

    open($fh, '<', $fileName || die "error");
    while (local $str = <$fh>)
    {
        # индекс мы сделали -1 изначально, поэтому как только достаем первую строку, то отрабатывает if, потом index++ и все остальные строки работает else, вот так отделяю заголовки и данные
        if ($index == -1) {
            # делим данные по пробелам
            @arrHeadings = split /\s+/, $str;
        } else {
            # делим данные по пробелам
            local @arrDataStr = split /\s+/, $str;
            # перебираем массив данных и 3аполняем двумерный массив данных
            for my $j (0 .. $#arrDataStr)
            {
                $arrData[$index][$j] = $arrDataStr[$j];
            }
        }
        # перед след строкой увеличиваем индекс
        $index++;
    }
    close($fh);

    # через "\" берем ссылку на @arrHeadings и @arrData и закидываем в $headings и $records соотв
    # в headings и records лежат ссылки! а не данные
    # данные все время остаются лежать в @arrHeadings и @arrData
    # и поиск, и добавление/удаление будет изменять данные в @arrData, $records просто ссылка на эту переменную еще раз!
    $headings = \@arrHeadings;
    $records = \@arrData;
    # посмотри как данные хранятся, и удали потом
    print(Dumper $records);
}

# перебирает данные и заносит их в переменную, которую потом выведем, т.е. функций не печатает, а пихает данные масивов в 1 переменную
sub PrepareToPrint {
    # сюда все запишем
    local $text = "";
    # сначала переписываем в строку все заголовки из массива заголовков
    foreach $heading (@{$headings})
    {
        $text .= $heading . "\t";
    }
    $text .= "\n";
    # потом переписываем все данные из двумерного массива данных
    foreach $arrRecord (@{$records})
    {
        foreach $recordData (@{$arrRecord})
        {
            $text .= $recordData . "\t";
        }
        # новая строка, перевод на неё
        $text .= "\n";
    }
    # возвращаем переменную с текстом
    return $text;
}

# Добавляем строку с данными
sub AddRecord {
    # массив с новыми данным пока пустой
    local @newData;
    # новые данные - заполнить каждый столбец данными, поэтому кол-во новых данных == кол-во столбцов
    # перебираем массив заголовков чтоб вывести каждый заголовок (типа вот щас заполняешь вот эти данные) и ограничить кол-во вводимых данных, из коммента выше следует
    for (my $i = 0; $i < $#{$headings} + 1; $i++)
    {
        # "Заголовок_Нейм: "
        print(${$headings}[$i] . ": ");
        # считываем данные с буфера консоли, заносим их в каждый раз заново создаваемую $inputValue
        local $inputValue = <>;
        chomp($inputValue);
        # закидываем введеное в массив новых данных под индексом текущего заголовка (типа id - 0, name - 1 и данные новые в таком же порядке с такими же индексами)
        $newData[$i] = $inputValue;
    }

    # обращаемся к ссылке как к массиву (@) и закидываем в этот массив ссылку на новые данные, теперь они добавлены
    push(@$records, \@newData);
    print("Добавлено\n");
}

# Сохранение данных из переменных в файл
sub SaveToFile {
    open($fh, '>', $fileName || die "error");
    # докидываем в принт fh - файл хэндлер и переменную какую отпечатать
    print($fh PrepareToPrint());
    close($fh);
    print("Сохранено");
}

# Удаление по id
sub DeleteRecordByID {
    print("ID фильма для удаления: ");
    # считываем id
    local $idToDelete = <>;
    chomp($idToDelete);

    # совпадение, если значение не изменится, то введеного id не существует
    local $deleteIndex = -1;

    # цикл перебирает массив, достает из него индекс элемента и сам элемент
    # $records - это ссылка, поэтому оборачиваем её в @{...} чтоб обратиться к ней как к массиву
    # each перебирает каждый элемент как раз
    while (my ($i, $element) = each(@{$records}))
    {
        # элементы, которые будем получать вида - ['123', 'film_name', ...]
        # т.е. мы получаем массивчики в качестве элементов, под [0] индексом лежит id, поэтому обращаемся к нему
        # eq - это как ==, только для строк, сравниваем id записей и искомый
        if (${$element}[0] eq $idToDelete)
        {
            # если нашли, то записываем его и last - как break, выходит из цикла, т.к. нам больше не надо искать
            $deleteIndex = $i;
            last;
        }
    }

    # если совпадение было, то
    if ($deleteIndex > -1)
    {
        print($deleteIndex . "\n");
        # splice вернет срез массива (массив, вырезанный из исходного), параметры: что мы режем (массив), индекс, с какого достаем, кол-во элементов чтоб достать
        splice(@{$records}, $deleteIndex, 1);
        print("Фильм с ID:\"$idToDelete\" удален\n");
    }
    else
    {
        print("Фильма с ID:\"$idToDelete\" не существует");
    }
}

# Поиск по всем данным
sub Search {
    print("Найти: ");
    # вводим что нам надо
    local $searchText = <>;
    chomp($searchText);

    # массив индексов строк, в которых будет совпадение, нам же не сугубо 1 вхождение нужно
    local @indexFound = ();

    # перебираем данные точно так же как в функции для удаление по id
    while (my ($i, $arrRecord) = each(@{$records}))
    {
        # но на этот раз, перебираем ещё и подмассив, т.к. нам нужно проверить каждый элемент, в отличии, от удаление по id, где мы знали, что id на месте [0]
        foreach $recordData (@{$arrRecord})
        {
            # recordData - очередное поле в массиве, смотрим через ~= если в нем подстрока искомая (искомое передается как регуляркаа
            if ($recordData =~ /$searchText/)
            {
                # если нашли хотя бы 1 вхождение, то сразу вносим индекс этой строки в массив вхождения и заканчиваем перебор массива строки
                push(@indexFound, $i);
                last;
            }
        }
    }

    # если кол-во вхождение > 0
    if (@indexFound > 0)
    {
        print("Результат:\n");
        # печатаем заголовки
        foreach $heading (@{$headings})
        {
            print($heading . "\t");
        }
        print("\n");

        # а теперь перебираем индексы строк, в которых есть вхождение, и печатаем
        foreach $index (@indexFound)
        {
            for (my $j = 0; $j < $#{$headings} + 1; $j++)
            {
                # обращение по $index
                print (${$records}[$index][$j] . "\t");
            }
            print("\n");
        }
    }
    else
    {
        print("ID: \"$searchText\" не нашлось\n");
    }
}

LoadDataFromFile();
my $do = "
0 - вывести данные
1 - добавить запись
2 - сохранить в файл
3 - удалить по ID
4 - найти
5 - выход
Действия: ";
print($do);

# бесконечный цикл
while (<>) {
    # ввод с консоли
    my $cm = $_;
    chomp($cm);
    if ($cm == 0) {
        print PrepareToPrint();
    }
    if ($cm == 1) {
        print AddRecord();
    }
    if ($cm == 2) {
        SaveToFile();
    }
    if ($cm == 3) {
        DeleteRecordByID();
    }
    if ($cm == 4) {
        Search();
    }
    if ($cm == 5) {
        exit(100);
    }
    print($do);
}